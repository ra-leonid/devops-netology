## Команды работы с потоками

`read new_var` - чтение с клавиатуры в переменную

`echo $new_var` - вывод переменной на экран

* **stdin** или **standard input** – стандартный ввод, условный номер **0**
  * ввод команды и ее аргументов в shell: `ls -l`, `man ls`
* **stdout** или **standard output** – стандартный вывод, условный номер **1**
  * вывод результата работы команды: листинг директорий `ls`, документация man
* **stderr** или **standard error** – стандартный вывод ошибок, условный номер **2**
  * вывод ошибок при работе команды: сообщение о вызове `ls` на несуществующую директорию, `man` на отсутствующую команду

Кроме файловых систем, предназначенных для работы с физическими накопителями, в Linux существуют и виртуальные псевдо-файловые системы, две из которых мы сегодня затронем:
* **/dev** (файловое представление устройств)
* **/proc** (файловое представление структур ядра)


`lsof` - вывод процессов, их файловых дескрипторов и задействованных в них файлов

**Примеры**:
* `lsof -i 4 -a -p 1234` (просмотр всех соединений IPv4, открытых процессом с PID = 1234)
* `lsof -i tcp:80` (просмотр информации о процессе, который прослушивает 80 TCP порт)
* `lsof /dev/hd4` (Список открытых файлов на устройстве /dev/hd4)
* `lsof /dev/cdrom` (Список процессов, работающих с CD ROM)
* `lsof -c ssh` (Список подключений по ssh)
* `lsof -p $$` - список открытых файлов нашим shell
 

`ls -l /proc/$$/fd/{0,1,2}` - отображение дескрипторов ввода/вывода нашего shell

`pstree -p` - вывод всех процессов в виде дерева

`echo $$` - PID текущего процесса shell (bash)

`echo $PPID` - PID **родителя** текущего процесса shell (bash)

`jobs -l` - вывод информации о задачах

`top` - список активных процессов

`tty` - имя используемого терминала

## Команды работы с системными устройствами

`uptime` - время работы операционной системы

`evtest` - вывод информации о системных устройствах

**Пример**:
`evtest /dev/input/event2` - информация о клавиатуре

## Остальные

`whereis` - информация о месторасположении файлов команды

`wc` - подсчитать количество строк или слов в тексте

`history` - история команд

`!2` - выполнить команду по номеру из истории

## Работа с сессиями

`screen` - создание screen-сессии. Особенность такой сессии заключается в том, что при разрыве соединения по ssh, она не прервёт своё выполнение

`screen -S имя_сессия_скрин` - создание именованной сессии


* Ctrl+a и c - создать дополнительное окно ;
* Ctrl+a и A - переименовать текущее окно;
* Ctrl+a и 0 - переключиться на окно с номером 0 (номер может быть иной);
* Ctrl+a и S - разделить окно по горизонтали на две области;
* Ctrl+a и | - разделить окно по вертикали на две области;
* Ctrl+a и tab - переключить рабочий фокус на следующую область разделенного окна;
* Ctrl+a и Ctrl+a - переключить рабочий фокус на предыдущую область разделенного окна;
* Ctrl+a и Q - закрыть все разделенные области кроме;
* Ctrl+a и " - показать список всех имеющихся окон;
* Ctrl+a и X - закрыть текущую область;

`Ctrl+a и d` - Выход из сессии. Запущенная вами в этот момент команда не остановится и будет продолжать свое выполнение.

`screen -r` - возврат к сессии

Если у вас запущено больше чем одна screen - сессия, то после ключа `-r` нужно указать ее ID. Узнать его просто с помощью команды:

`screen -ls`

Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Для этого используем `reptyr`. Так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии:

* `echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope` - временно разрешаем подключение к удаленной программе (без этой команды будет ошибка: "*The kernel denied permission while attaching. If your uid matches the target's, check the value of /proc/sys/kernel/yama/ptrace_scope*").
* Создаем продолжительный процесс `top`
* Останавливаем его `Ctrl+z`
* Отключаем задание от родителя `disown top`. В результате выполнения команды выведется PID отключенного процесса. Запоминаем его.
```commandline
vagrant@vagrant:~$ disown top
-bash: warning: deleting stopped job 1 with process group 1287
```
* Запускаем мультиплексор терминала `screen -S top`
* Подключаемся к фоновому процессу `reptyr 1287`
* Выходим `Ctrl-a d`
* Всё, можем отключаться от сессии ssh, при повторном входе и подключению к терминалу screen, мы увидим свой процесс 

## Vagrant

`vagrant ssh` - подключиться по SSH под юзером vagrant

`vagrant suspend` - поставить на паузу

`vagrant halt` - выключить

`vagrant reload` - перезагрузить конфиг (без выполнения provision)

`vagrant reload --provision`

`vagrant destroy` - удалить виртуалку

`vagrant box list` - cписок доступных "боксов"

## Операционная система

`ldd` - вывод зависимостей общих объектов

Пример:
`ldd $(which ls)` - выведет зависимости команды `ls`

### Приложение > библиотечный вызов > системный вызов

`sotruss` - отслеживание вызовов общих библиотек через PLT

`strace` – программа, использующая подсистему ядра ptrace для отслеживания системных вызовов. Основной недостаток strace – замедление работы приложений, в десятки или даже сотни раз, поэтому в production среде применяйте аккуратно.

Пример CPython: 
1. функция print языка Python делает библиотечный вызов libc write:
```commandline
sotruss python3 -c 'print("Hi, Netology!")' 2>&1 | grep write
        python3 -> libc.so.6      :*write(0x1, 0xb96880, 0xe)
```

2. библиотечный вызов libc, в свою очередь, делает системный вызов write:
```commandline
vagrant@netology1:~$ strace -e trace=write python3 -c 'print("Hi, Netology!")'>/dev/null
        write(1, "Hi, Netology!\n", 14)         = 14+++ exited with 0 +++
```

* `strace -p $(pgrep -f 'nginx: worker')` - отслеживание системных вызовов в работающей программе.
* `strace -f sh -c date` - флаг `-f` трейсинг процесса и его потомков.
* По умолчанию вывод строк strace ограничен 32 байтам. Используйте `-s` с требуемой длиной строки, чтобы увидеть полные сообщения, например `-s 65000`. В таком случае может пригодиться и `-o` для записи в файл вместо вывода на экран.
* `-y` – аннотации к файловым дескрипторам.
* Очень часть системным администраторам помогает `strace -e open`: показывает чтение конфигурационных файлов из разных мест, недоступные ресурсы и т.д.

eBPF - еще один инструмент (не использует ptrace), позволяющий отследить, что происходит в ОС. Фактически, это целый язык программирования, который генерирует микропрограммы для исполнения ядром и может манипулировать или следить за различными подсистемами.eBPF не ограничен привязкой к системным или библиотечным вызовам, а также не влияет на производительность. Рекомендуем ознакомиться с полезным набором утилит iovisor BCC. Изучите список готовых eBPF программ – многие вам понадобятся.Например, можно посмотреть все новые процессы, появляющиеся в системе:
```commandline
root@netology1:~# execsnoop-bpfcc
PCOMM            PID    PPID   RET ARGS
systemctl        174640 24777    0 /usr/bin/systemctl status nginx
systemctl        174641 24777    0 /usr/bin/systemctl status nginx
```
## Оценка потребления ресурсов

`free -m`, `free -g` - обзор памяти в МБ и ГБ

```commandline
└─ > free -g
              всего        занято        свободно      общая  буф./врем.   доступно
Память:          11           2           6           0           3           8
Подкачка:        11           0          11
```

Кэш можно сбросить, тем самым высвободится память. Но кэш буферизирует горячие данные, для быстрого запуска и если очистить то работа их замедлится.
Операция сервера приложений может первый раз выполняться чуть больше, но она кешируется в буфер и после этого выполняется намного быстрее.

Сбрасывается кэш командой:

`sync && echo 3 | sudo tee /proc/sys/vm/drop_caches`

Перед выполнением операции необходимо запустить команду sync
* 
* 1 - очистка pagecache
* 2 - очистка dentrie и inode кэшей
* 3 - очистка pagecache, dentrie и inode кэшей

`top` – просмотреть список активных процессов в системе с сортировкой по потребляемому процессорному времени (по умолчанию), Shift + F - для интерактивного меню, где s – меняет сортировку и d – включает/выключает отображение колонки.

`atop` – программа для записи исторического top с заданным интервалом. Возможно, с учетом современных подходов к сбору метрик и eBPF уже не столь актуальна, но может быть полезна. t / Shift + t для перехода по интервалам, atop -r <log> -b <time> для старта с нужного времени.echo LOGINTERVAL=10 > /etc/default/atop; systemctl restart atop

`htop` – более современный вариант top. top был написан задолго до эпохи много-ядерных систем, htop представляет нагрузку с учетом визуализации отдельных ядер.

`mpstat` – аналогичная по сути тестовая утилита с более подробной статистикой.
```commandline
~ # mpstat -P ALL 1
Linux 4.19.102+ (api-6f74c84dfb-wlrrz)_x86_64_(12 CPU)
18:53:40     CPU    %usr   %nice    %sys %iowait    %idle
18:53:41     all    9.55    0.00    2.09    0.00    88.11
18:53:41       0    1.00    0.00    0.00    0.00    97.00
18:53:41       5   26.73    0.00    6.93    0.00    65.35
18:53:41       9   30.00    0.00    7.00    0.00    63.00
18:53:41      10   33.33    0.00    6.06    0.00    60.61
```
`iotop` – аналогичная top утилита, только для дисковой подсистемы. Далеко не всегда, даже на специализированном сервере (баз данных) очевидно, какой процесс вызывает высокую загрузку дисков, iotop поможет в этом разобраться.

Само по себе знание о загрузке сетевого линка не говорит нам о том, на что действительно расходуется полоса. `iftop` поможет в этом.

iftop показывает сетевое взаимодействие без привязки к процессом. Для подобной статистики запустите `nethogs <interface>`.

Нередко на хосте бывает несколько сетевых интерфейсов, и может быть важно оценить загрузку по ним. В такой ситуации поможет `sar -n DEV 1`