## Команды работы с потоками

`read new_var` - чтение с клавиатуры в переменную

`echo $new_var` - вывод переменной на экран

* **stdin** или **standard input** – стандартный ввод, условный номер **0**
  * ввод команды и ее аргументов в shell: `ls -l`, `man ls`
* **stdout** или **standard output** – стандартный вывод, условный номер **1**
  * вывод результата работы команды: листинг директорий `ls`, документация man
* **stderr** или **standard error** – стандартный вывод ошибок, условный номер **2**
  * вывод ошибок при работе команды: сообщение о вызове `ls` на несуществующую директорию, `man` на отсутствующую команду

Кроме файловых систем, предназначенных для работы с физическими накопителями, в Linux существуют и виртуальные псевдо-файловые системы, две из которых мы сегодня затронем:
* **/dev** (файловое представление устройств)
* **/proc** (файловое представление структур ядра)


`lsof` - вывод процессов, их файловых дескрипторов и задействованных в них файлов

**Примеры**:
* `lsof -i 4 -a -p 1234` (просмотр всех соединений IPv4, открытых процессом с PID = 1234)
* `lsof -i tcp:80` (просмотр информации о процессе, который прослушивает 80 TCP порт)
* `lsof /dev/hd4` (Список открытых файлов на устройстве /dev/hd4)
* `lsof /dev/cdrom` (Список процессов, работающих с CD ROM)
* `lsof -c ssh` (Список подключений по ssh)
* `lsof -p $$` - список открытых файлов нашим shell
 

`ls -l /proc/$$/fd/{0,1,2}` - отображение дескрипторов ввода/вывода нашего shell

`pstree -p` - вывод всех процессов в виде дерева

`echo $$` - PID текущего процесса shell (bash)

`echo $PPID` - PID **родителя** текущего процесса shell (bash)

`jobs -l` - вывод информации о задачах

`top` - список активных процессов

`tty` - имя используемого терминала

## Команды работы с системными устройствами

`uptime` - время работы операционной системы

`evtest` - вывод информации о системных устройствах

**Пример**:
`evtest /dev/input/event2` - информация о клавиатуре

## Остальные

`whereis` - информация о месторасположении файлов команды

`wc` - подсчитать количество строк или слов в тексте

`history` - история команд

`!2` - выполнить команду по номеру из истории

## Работа с сессиями

`screen` - создание screen-сессии. Особенность такой сессии заключается в том, что при разрыве соединения по ssh, она не прервёт своё выполнение

`screen -S имя_сессия_скрин` - создание именованной сессии


* Ctrl+a и c - создать дополнительное окно ;
* Ctrl+a и A - переименовать текущее окно;
* Ctrl+a и 0 - переключиться на окно с номером 0 (номер может быть иной);
* Ctrl+a и S - разделить окно по горизонтали на две области;
* Ctrl+a и | - разделить окно по вертикали на две области;
* Ctrl+a и tab - переключить рабочий фокус на следующую область разделенного окна;
* Ctrl+a и Ctrl+a - переключить рабочий фокус на предыдущую область разделенного окна;
* Ctrl+a и Q - закрыть все разделенные области кроме;
* Ctrl+a и " - показать список всех имеющихся окон;
* Ctrl+a и X - закрыть текущую область;

`Ctrl+a и d` - Выход из сессии. Запущенная вами в этот момент команда не остановится и будет продолжать свое выполнение.

`screen -r` - возврат к сессии

Если у вас запущено больше чем одна screen - сессия, то после ключа `-r` нужно указать ее ID. Узнать его просто с помощью команды:

`screen -ls`

Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Для этого используем `reptyr`. Так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии:

* `echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope` - временно разрешаем подключение к удаленной программе (без этой команды будет ошибка: "*The kernel denied permission while attaching. If your uid matches the target's, check the value of /proc/sys/kernel/yama/ptrace_scope*").
* Создаем продолжительный процесс `top`
* Останавливаем его `Ctrl+z`
* Отключаем задание от родителя `disown top`. В результате выполнения команды выведется PID отключенного процесса. Запоминаем его.
```commandline
vagrant@vagrant:~$ disown top
-bash: warning: deleting stopped job 1 with process group 1287
```
* Запускаем мультиплексор терминала `screen -S top`
* Подключаемся к фоновому процессу `reptyr 1287`
* Выходим `Ctrl-a d`
* Всё, можем отключаться от сессии ssh, при повторном входе и подключению к терминалу screen, мы увидим свой процесс 

## Vagrant

`vagrant ssh` - подключиться по SSH под юзером vagrant

`vagrant suspend` - поставить на паузу

`vagrant halt` - выключить

`vagrant reload` - перезагрузить конфиг (без выполнения provision)

`vagrant reload --provision`

`vagrant destroy` - удалить виртуалку

`vagrant box list` - cписок доступных "боксов"

## Операционная система

`ldd` - вывод зависимостей общих объектов

Пример:
`ldd $(which ls)` - выведет зависимости команды `ls`

### Приложение > библиотечный вызов > системный вызов

`sotruss` - отслеживание вызовов общих библиотек через PLT

`strace` – программа, использующая подсистему ядра ptrace для отслеживания системных вызовов. Основной недостаток strace – замедление работы приложений, в десятки или даже сотни раз, поэтому в production среде применяйте аккуратно.

Пример CPython: 
1. функция print языка Python делает библиотечный вызов libc write:
```commandline
sotruss python3 -c 'print("Hi, Netology!")' 2>&1 | grep write
        python3 -> libc.so.6      :*write(0x1, 0xb96880, 0xe)
```

2. библиотечный вызов libc, в свою очередь, делает системный вызов write:
```commandline
vagrant@netology1:~$ strace -e trace=write python3 -c 'print("Hi, Netology!")'>/dev/null
        write(1, "Hi, Netology!\n", 14)         = 14+++ exited with 0 +++
```

* `strace -p $(pgrep -f 'nginx: worker')` - отслеживание системных вызовов в работающей программе.
* `strace -f sh -c date` - флаг `-f` трейсинг процесса и его потомков.
* По умолчанию вывод строк strace ограничен 32 байтам. Используйте `-s` с требуемой длиной строки, чтобы увидеть полные сообщения, например `-s 65000`. В таком случае может пригодиться и `-o` для записи в файл вместо вывода на экран.
* `-y` – аннотации к файловым дескрипторам.
* Очень часть системным администраторам помогает `strace -e open`: показывает чтение конфигурационных файлов из разных мест, недоступные ресурсы и т.д.

eBPF - еще один инструмент (не использует ptrace), позволяющий отследить, что происходит в ОС. Фактически, это целый язык программирования, который генерирует микропрограммы для исполнения ядром и может манипулировать или следить за различными подсистемами.eBPF не ограничен привязкой к системным или библиотечным вызовам, а также не влияет на производительность. Рекомендуем ознакомиться с полезным набором утилит iovisor BCC. Изучите список готовых eBPF программ – многие вам понадобятся.Например, можно посмотреть все новые процессы, появляющиеся в системе:
```commandline
root@netology1:~# execsnoop-bpfcc
PCOMM            PID    PPID   RET ARGS
systemctl        174640 24777    0 /usr/bin/systemctl status nginx
systemctl        174641 24777    0 /usr/bin/systemctl status nginx
```
## Оценка потребления ресурсов

`free -m`, `free -g` - обзор памяти в МБ и ГБ

```commandline
└─ > free -g
              всего        занято        свободно      общая  буф./врем.   доступно
Память:          11           2           6           0           3           8
Подкачка:        11           0          11
```

Кэш можно сбросить, тем самым высвободится память. Но кэш буферизирует горячие данные, для быстрого запуска и если очистить то работа их замедлится.
Операция сервера приложений может первый раз выполняться чуть больше, но она кешируется в буфер и после этого выполняется намного быстрее.

Сбрасывается кэш командой:

`sync && echo 3 | sudo tee /proc/sys/vm/drop_caches`

Перед выполнением операции необходимо запустить команду sync
* 
* 1 - очистка pagecache
* 2 - очистка dentrie и inode кэшей
* 3 - очистка pagecache, dentrie и inode кэшей

`top` – просмотреть список активных процессов в системе с сортировкой по потребляемому процессорному времени (по умолчанию), Shift + F - для интерактивного меню, где s – меняет сортировку и d – включает/выключает отображение колонки.

`atop` – программа для записи исторического top с заданным интервалом. Возможно, с учетом современных подходов к сбору метрик и eBPF уже не столь актуальна, но может быть полезна. t / Shift + t для перехода по интервалам, atop -r <log> -b <time> для старта с нужного времени.echo LOGINTERVAL=10 > /etc/default/atop; systemctl restart atop

`htop` – более современный вариант top. top был написан задолго до эпохи много-ядерных систем, htop представляет нагрузку с учетом визуализации отдельных ядер.

`mpstat` – аналогичная по сути тестовая утилита с более подробной статистикой.
```commandline
~ # mpstat -P ALL 1
Linux 4.19.102+ (api-6f74c84dfb-wlrrz)_x86_64_(12 CPU)
18:53:40     CPU    %usr   %nice    %sys %iowait    %idle
18:53:41     all    9.55    0.00    2.09    0.00    88.11
18:53:41       0    1.00    0.00    0.00    0.00    97.00
18:53:41       5   26.73    0.00    6.93    0.00    65.35
18:53:41       9   30.00    0.00    7.00    0.00    63.00
18:53:41      10   33.33    0.00    6.06    0.00    60.61
```
`iotop` – аналогичная top утилита, только для дисковой подсистемы. Далеко не всегда, даже на специализированном сервере (баз данных) очевидно, какой процесс вызывает высокую загрузку дисков, iotop поможет в этом разобраться.

Само по себе знание о загрузке сетевого линка не говорит нам о том, на что действительно расходуется полоса. `iftop` поможет в этом.

iftop показывает сетевое взаимодействие без привязки к процессом. Для подобной статистики запустите `nethogs <interface>`.

Нередко на хосте бывает несколько сетевых интерфейсов, и может быть важно оценить загрузку по ним. В такой ситуации поможет `sar -n DEV 1`

### node_exporter
Приведенные выше инструменты хороши для интерактивной оценки производительности системы, но они не решают проблемы сбора исторических данных.

Решение: актуальная связка Prometheus + node_exporter.

С коллектором вы познакомитесь в модуле по мониторингу, но на node_exporter логично взглянуть на этой лекции.

```commandline
vagrant@netology1:~/node_exporter-1.0.1.linux-amd64$ curl -s localhost:9100/metrics2>/dev/null | grep node_filesystem_avail_bytes | grep mapper
node_filesystem_avail_bytes{device="/dev/mapper/vgvagrant-root",fstype="ext4",mountpoint="/"} 6.075752448e+10

vagrant@netology1:~/node_exporter-1.0.1.linux-amd64$ df -h | grep mapper
/dev/mapper/vgvagrant-root   62G  1.6G   57G   3% /
```

# Ядро, модули

## Ядро и дистрибутив

`uname -r` - Посмотреть версию ядра, с которой работает ОС

`cat /etc/issue`, `lsb_release -a` - сведения о дистрибутиве

`grep -v ^# /boot/config-$(uname -r) | tail -n2` - Посмотреть, с какой конфигурацией ядро собрано

В современных ОС ядра распространяются в форме пакетов, как и другие приложения:
```commandline
root@netology1:~# dpkg -l | grep linux-image-5
ii  linux-image-5.4.0-31-generic  5.4.0-31.35   amd64    Signed kernel image generic
```

Установочные скрипты сами обновляют записи загрузчика, initrd и vmlinuz (бинарный образ ядра).

## Модули ядра
По формальной классификации ядро Linux – монолитное. Несмотря на это, есть возможность динамически подгружать и выгружать модули.

`lsmod | wc -l` - Посмотреть загруженные

Классическая команда для загрузки нового модуля – insmod (insert module), однако есть более удобный современный вариант – modprobe, который умеет автоматически подгружать зависимости и не требует указания пути:
```commandline
vagrant@netology1:~$ modinfo virtio_net | grep depends
depends: net_failover
… sudo insmod /lib/modules/$(uname -r)/kernel/drivers/net/virtio_net.ko
insmod: ERROR: could not insert module
/lib/modules/5.4../kernel/drivers/net/virtio_net.ko: Unknown symbol in module
vagrant@netology1:~$ sudo modprobe virtio_net
```

## Настройка ядра – параметры загрузки
В части параметров настройки ядро Linux аналогично обычным приложениям - оно принимает строку параметров на вход.
```commandline
vagrant@netology1:~$ cat /proc/cmdline
BOOT_IMAGE=/boot/vmlinuz-5.4.0-31-generic root=/dev/mapper/vgvagrant-root ro net.ifnames=0 biosdevname=0 quiet
```
В данном примере:
* загрузчик передал путь до образа, из которого ядро загружено;
* на каком устройстве находится корневая файловая система;
* монтировать корневую файловую систему в RO режиме во время загрузки;
* параметры для подсистемы udev об именовании сетевых интерфейсов;
* “тихая” загрузка без сообщений.

Настройки загрузчика специфичны для дистрибутива. В Ubuntu изменить их можно через приведенный файл и запустив sudo update-grub.

```commandline
vagrant@netology1:~$ grep GRUB_CMDLINE_LINUX /etc/default/grub
GRUB_CMDLINE_LINUX_DEFAULT="quiet"
GRUB_CMDLINE_LINUX="net.ifnames=0 biosdevname=0 "
```
Если доступа в загруженную ОС нет, параметры ядра можно поменять во время работы загрузчика через его сервисное меню (**init=/bin/sh** или **single** для **single user mode**).

## Настройка ядра – sysctl
Параметров ядра существуют больше тысячи - передавать их в командной строке и каждый раз перезагружаться неудобно. Для решения данной проблемы существует механизм sysctl.
```commandline
root@netology1:~# sysctl -a | grep 'v4.ip_forward '
net.ipv4.ip_forward = 0
root@netology1:~# sysctl -w net.ipv4.ip_forward=1
net.ipv4.ip_forward = 1
root@netology1:~# sysctl net.ipv4.ip_forward
net.ipv4.ip_forward = 1
```
Внесенные таким образом изменения не сохранятся после перезагрузки. Чтобы сделать их персистентными, присутствует каталог **/etc/sysctl.d**. В дистрибутивах обычно ряд настроек заданы отличными от стандартных, поэтому ознакомьтесь с имеющимися там параметрами до внесения своих.
```commandline
root@netology1:~# grep -v '^#' /etc/sysctl.d/* | grep = | column -t | head -n2
/etc/sysctl.d/10-console-messages.conf:kernel.printk = 4 4 1 7
/etc/sysctl.d/10-ipv6-privacy.conf:net.ipv6.conf.all.use_tempaddr = 2
```
Применить изменения (без указания `-p` загрузит **/etc/sysctl.conf**):
```commandline
root@netology1:~# sysctl -p /etc/sysctl.d/10-ipv6-privacy.conf
net.ipv6.conf.all.use_tempaddr = 1
net.ipv6.conf.default.use_tempaddr = 2
```

## dmesg и syslog
Два важных источника информации об ОС:
1. `dmesg` – инструмент доступа к записям ядра. В `dmesg` (ключ -T – конвертировать время в человеко-читаемое) присутствует информация о загрузке ОС, об изменении состояния аппаратных ресурсов. Проблемы с дисками, отвалившиеся сетевые карты, ошибки при коррекции ошибок ECC – многие обращающие на себя внимание сообщения найдут свое место здесь.
```commandline
root@netology1:~# dmesg -T | tail -n2
[19:27:11 2020] e1000: eth1 NIC Link is Up 1000 Mbps Full Duplex...
[19:27:11 2020] IPv6: ADDRCONF(NETDEV_CHANGE): eth1: link becomes ready
```
2. `syslog` – штатный логгер, куда попадают сообщения уже от приложений в юзерспейсе. Мест, куда приложения могут писать логи, – множество: от локальных файлов до сервисов вроде journald. Однако **/var/log/syslog** остается местом, куда стоит заглянуть при оценке состояния системы.

# Системы инициализации:

## systemd, init – PID 1, процессы ядра

Мы узнали, что новые процессы в Linux создаются клонированием родительского процесса. Из этого правила есть понятное исключение – первый процесс в системе, который ядро создает самостоятельно и назначает ему PID 1, – init. 

**init** – собирательное название для контроллера инициализации ОС, а не конкретная технология.

Система инициализации отвечает за:
* достижение корректного состояния на разных этапах загрузки;
* запуска служб самой ОС и прикладных программ в нужном порядке;
* монтирование файловых систем;
* обратный процесс при выключении ОС;
* init должен уметь “усыновлять” процессы, ставшие “сиротами”.

**init** – не единственный процесс, который создан ядром. Процессы в `ps` в квадратных скобках – “ядерные” процессы, что видно по 0 размеру RSS памяти в юзер-спейсе.

## systemd, systemctl
Систем инициализации было разработано много, но стандарт для большинства популярных дистрибутивов сегодня – systemd.

**systemd** многие критикуют за несоответствие философии Unix, согласно которой у программы должно быть единственное предназначение, которое она должна выполнять хорошо.

**systemd** же, будучи системой инициализации, сегодня заменяет множественные сервисы ОС: логирование, планировщик задач cron, даже локальный кеширующий DNS и синхронизация времени есть в стандартной поставке, что вообще никак не связано с системой инициализации.

Базовые команды:
* `systemctl list-units --all` - (посмотреть все юниты под управлением systemd)
* `systemctl status nginx.service` - (посмотреть статус работы сервиса) сразу же виден путь расположения юнит-файла, который отвечает за сервис (/lib/systemd/system/nginx.service в нашем случае)
* `systemctl start/stop/restart/reload nginx` - (.service можно опустить если типа юнита один)
* `systemctl enable/disable nginx` - (автозапуск сервиса включен/выключен)

## journalctl, systemctl

* `systemctl cat nginx.service`
* `systemctl edit --full nginx.service`
* `systemctl daemon-reload` - (перечитать измененные юнит-файлы самого systemd)
* `systemctl list-dependencies nginx.service` - (посмотреть зависимости сервиса nginx)
* `journalctl -b -u nginx.service` - (посмотреть логи сервиса nginx, которые были записаны с момента загрузки, b от boot)

## Неймспейсы процессов

Основная концепция контейнеров – **пространства имен**. Все, о чем мы с вами говорили, будь то командный интерпретатор bash, процессы-потомки, запущенные из него, – все это тоже находилось в пространстве имен по умолчанию.

`lsns` - показать неймспейсы процессов

Таким нехитрым образом можно организовать полностью изолированный от хостового неймспейс, в котором PID 1 будет иметь команда, которую мы запустили.
```commandline
root@netology1:~# screen
root@netology1:~# unshare -f --pid --mount-proc /bin/bash
root@netology1:~# ps aux
USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND
root 1 0.0 0.3 9836 3980 pts/0 S 07:29 0:00 /bin/bash
root 8 0.0 0.3 11476 3316 pts/0 R+ 07:29 0:00 ps aux
```
Из хостового NS при этом наш процесс имеет совершенно обычный PID:
```commandline
root 237934 0.0 0.0 8080 596 pts/3 S 07:30 0:00 \_ unshare -f --pid…
root 237935 0.0 0.3 9836 4012 pts/3 S+ 07:30 0:00 \_ /bin/bash
```
Имея привилегии, можно “зайти” в этот namespace с хоста:
```commandline
root@netology1:~# nsenter --target 237935 --pid --mount
root@netology1:/# ps aux
USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND
root 1 0.0 0.3 9836 4012 pts/3 S+ 07:30 0:00 /bin/bash
root 28 0.0 0.4 9836 4168 pts/0 S 07:38 0:00 -bash
root 37 0.0 0.3 11476 3396 pts/0 R+ 07:38 0:00 ps aux
```

### diff - команда сравнения результата выполнения 2-х команд
```commandline
diff <(helm template 13-kubernetes-config) <(helm template --set frontend.image.tag=0.2.0 13-kubernetes-config)
116c116
<           image: "raleonid/frontend:latest"
---
>           image: "raleonid/frontend:0.2.0"

```